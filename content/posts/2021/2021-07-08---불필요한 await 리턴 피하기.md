---
title: Disallows unnecessary return await (no-return-await) Eslint 오류
date: "2021-07-08"
template: "post"
draft: true
slug: "/posts/programming/eslint/return-await"
category: "programming"
tags:
  - "return await"
  - "왜 await를 리턴하면 안되는가?"
  - "불필요한 await 리턴오류"
  - "eslint error"
description: 불필요하게 await를 리턴하지 마세요. cpu 낭비입니다
---

최근에 업무를 하다가 아래와 같이 두 줄로 끝나는 함수가 있어서 한 줄로 그냥 리턴하면 어떨까 하고 생각해보게 됬는데요.

```js
  async fetchStoreDetailBrowser (_, { storeId }) {
    const storeDetail = await this.$axios.$get(endpoints.storeDetailBrowser(storeId))
    return storeDetail
  },

  // 아래와 같이 바꾸면 어떨까?
  async fetchStoreDetailBrowser (_, { storeId }) {
    return await this.$axios.$get(endpoints.storeDetailBrowser(storeId))
  },
```

<br>

아래에 더 추가적인 로직이 없다면 깔끔하게 끝나는 것 같이 보여 좋아보이긴 합니다. 하지만 eslint에서 이런 오류를 발견할 수 있습니다.
[eslint org](https://eslint.org/docs/rules/no-return-await)에서 더 자세한 내용을 확인 할 수 있었습니다.

문서를 읽어보면 이렇게 쓰여 있습니다.

> **async function** 내부에서 **return await**를 사용하는 것은 대기 중인 Promise가 해결될 때까지 호출 스택에 현재 함수가 유지됩니다.

역시나 항상 이해하기 어려운데요. 더 짧고 와닿게 얘기하면 <u> Call stack 내부에 함수를 붙잡아 두어 CPU 낭비가 발생하기 때문입니다.</u>

eslint 문서에서 링크로 달아놓은 async await 관련 예제를 살펴보도록 하겠습니다.

```js
async function waitAndMaybeReject() {
  // Wait one second
  await new Promise((r) => setTimeout(r, 1000));
  // Toss a coin
  const isHeads = Boolean(Math.round(Math.random()));

  if (isHeads) return "yay";
  throw Error("Boo!");
}
```

이런 함수가 있다고 합니다. 이 함수는 settimeout Promise와 함께 동전던지기를 해서 50:50의 확률로 yay를 리턴하거나 에러로 Boo를 던지는 함수입니다.


## 키워드 없이 호출할 경우 


```js
async function foo() {
  try {
    waitAndMaybeReject();
  } catch (e) {
    return "caught";
  }
}
```
만약 여기서 이렇게 그냥 부르면 어떻게 될까요? 

<span class="color--red">정답:</span> <u>waiting 없이 undefined만 반환함.</u>


## Await 키워드 붙였을 때 

위 문제는 Async에 익숙하신 분들이라면 어렵지 않았으리라고 생각합니다. 

```js
async function foo() {
  try {
    await waitAndMaybeReject();
  }
  catch (e) {
    return 'caught';
  }
}
```

그렇다면 await 키워드를 붙이게 된다면 어떻게 될까요?

<span class="color--red">정답:</span> <u>1초를 기다리고 undefind 혹은 "caught"를 반환</u>

Boo는 반환하지 않습니다. 왜냐면 `waitAndMaybeReject`의 결과값을 받기 때문인데요. 오류가 생겼다면 try catch 블록에서 잡기 때문에 'caught'를 반환하게 되는 것입니다.


## 리턴 시켰을 때
https://jakearchibald.com/2017/await-vs-return-vs-return-await/